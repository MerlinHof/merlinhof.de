class GraphicsEngine {
  #frameInterval;
  #frameFunctions;
  constructor(container) {
    this.canvas = document.createElement("canvas");
    container.appendChild(this.canvas);
    this.canvas.style.width = "100%";
    this.canvas.style.height = "100%";
    this.ctx = this.canvas.getContext("2d");
    let width = this.canvas.clientWidth;
    let height = this.canvas.clientHeight;
    this.canvas.setAttribute("height", height * window.devicePixelRatio);
    this.canvas.setAttribute("width", width * window.devicePixelRatio);
    this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    this.ctx.lineCap = "round";

    this.camera = new Camera(width, height);
    this.scene = new Scene();
    this.frameRate = 60;
    this.#frameFunctions = [];
  }

  // Called by the User to Start the Engine
  start() {
    this.#frameInterval = setInterval(() => {
      for (let ff of this.#frameFunctions) ff.func();
      this.ctx.clearRect(0, 0, this.camera.screenWidth, this.camera.screenHeight);
      for (let i = 0; i < this.scene.objectCount; i++) {
        let object = this.scene.get(i);
        object.draw(this);
      }
    }, 1000/this.frameRate);
  }

  // Called by the User to Stop the Engine
  stop() {
    clearInterval(this.#frameInterval);
  }

  addFrameFunction(func) {
    let id = Math.floor(Math.random()*10000);
    this.#frameFunctions.push({
      func: func,
      id: id
    });
    return id;
  }
  removeFrameFunction(id) {
    for (let i = 0; i < this.#frameFunctions.length; i++) {
      if (this.#frameFunctions[i].id == id) {
        this.#frameFunctions.splice(i, 1);
        break;
      }
    }
  }
}


// Scene Class
class Scene {
  #objects;
  constructor() {
    this.#objects = [];
    this.objectCount = 0;
  }
  add(object) {
    if (!(object instanceof GraphicsObject)) throw new Error("You can only add elements of the type GraphicsObject to the scene.");
    this.#objects.push(object);
    this.objectCount = this.#objects.length;
  }
  remove(object) {
    let index = this.#objects.indexOf(object);
    if (index != -1) {
      this.#objects.splice(index, 1);
      this.objectCount = this.#objects.length;
    }
  }
  get(index) {
    return this.#objects[index];
  }
}


class Camera {
  constructor(width, height) {
    this.position = new Point(0, 0, 0);
    this.rotation = new Vector(0, 0, 0);
    this.focalLength = 80;
    this.screenWidth = width;
    this.screenHeight = height;
  }
  getPlane() {
    let plane = new Plane();
    plane.position = new Point(0, this.focalLength, 0);
    plane.size = new Vector(1, 0, 1);
    plane.rotation = new Vector(0, 0, 0);
    return plane;
  }
  // Projects a 3D Point to the 2D camera plane
  projectPoint(point, shiftTo) {
    let cameraPlane = this.getPlane();
    point = point.toVector().sub(this.position).toPoint();
    point = point.rotate(new Point(0, 0, 0), this.rotation);
    if (point.y < 0) {
      if (shiftTo == undefined || shiftTo.y < 0) return null;
      shiftTo = shiftTo.toVector().sub(this.position).toPoint();
      shiftTo = shiftTo.rotate(new Point(0, 0, 0), this.rotation);
      let line = new Path([point, shiftTo]);
      point = (new Plane(new Point(0, 0, 0), cameraPlane.size)).intersect(line);
      point.y += 0.1;
    }
    let line = new Path([new Point(0, 0, 0), point]);
    let intersectionPoint = cameraPlane.intersect(line);
    intersectionPoint.x = this.screenWidth/2+10*intersectionPoint.x;
    intersectionPoint.z = this.screenHeight/2-10*intersectionPoint.z;
    return intersectionPoint;
  }
}








class Color {
  static white = new Color(255, 255, 255);
  constructor(red=0, green=0, blue=0, alpha=1.0) {
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  toString() {
    return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
  }
}


class Point {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  toVector() {
    return new Vector(this.x, this.y, this.z);
  }
  equals(p) {
    return (this.x == p.x && this.y == p.y && this.z == p.z);
  }
  // This Method was generated by OpenAI ChatGPT (12.12.2022)
  rotate(center, rotationVector) {
    const dx = this.x - center.x;
    const dy = this.y - center.y;
    const dz = this.z - center.z;
    const sinX = Math.sin(rotationVector.x);
    const cosX = Math.cos(rotationVector.x);
    const sinY = Math.sin(rotationVector.y);
    const cosY = Math.cos(rotationVector.y);
    const sinZ = Math.sin(rotationVector.z);
    const cosZ = Math.cos(rotationVector.z);
    const x1 = cosY * (sinZ * dy + cosZ * dx) - sinY * dz;
    const y1 = sinX * (cosY * dz + sinY * (sinZ * dy + cosZ * dx)) + cosX * (cosZ * dy - sinZ * dx);
    const z1 = cosX * (cosY * dz + sinY * (sinZ * dy + cosZ * dx)) - sinX * (cosZ * dy - sinZ * dx);
    return new Point(x1+center.x, y1+center.y, z1+center.z);
  }
}


class Vector {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  add(v) {
    return new Vector(this.x+v.x, this.y+v.y, this.z+v.z);
  }
  sub(v) {
    return new Vector(this.x-v.x, this.y-v.y, this.z-v.z);
  }
  getLength() {
    return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
  }
  normalize() {
    return this.scale(1/this.getLength());
  }
  scale(f) {
    return new Vector(this.x*f, this.y*f, this.z*f);
  }
  getDistanceTo(point) {
    let dx = this.x-point.x;
    let dy = this.y-point.y;
    let dz = this.z-point.z;
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
  }
  toPoint() {
    return new Point(this.x, this.y, this.z);
  }
  crossProduct(v) {
    let x = (this.y*v.z) - (this.z*v.y);
    let y = (this.z*v.x) - (this.x*v.z);
    let z = (this.x*v.y) - (this.y*v.x);
    return new Vector(x, y, z);
  }
  dotProduct(v) {
    return this.x*v.x + this.y*v.y + this.z*v.z;
  }
}









class GraphicsObject {
  constructor(position, size) {
    this.lineColor = new Color(255, 255, 255);
    this.lineWidth = 3;
    this.fillColor = new Color(255, 255, 255, 0.2);
    this.filled = false;
    this.position = position || new Point(0, 0, 0);
    this.size = size || new Vector(0, 0, 0);
    this.rotationCenter;
    this.rotation = new Vector(0, 0, 0);
  }
  draw(graphics) {
    graphics.ctx.fillStyle = this.fillColor.toString();
    graphics.ctx.strokeStyle = this.lineColor.toString();
    graphics.ctx.lineWidth = this.lineWidth;
    this.drawObject(graphics);
  }
  getRelevantPoints() {
    throw new Error("Not implemented");
  }
  drawObject() {
    throw new Error("Not implemented");
  }
  projectedDistanceTo2dPoint() {
    throw new Error("Not implemented");
  }
}


class Dot extends GraphicsObject {
  constructor(position, size) {
    super(position, size);
    this.fillColor = new Color(220, 30, 150);
  }
  toPoint() {
    return new Point(this.position.x, this.position.y, this.position.z);
  }
  getRelevantPoints(graphics) {
    return graphics.camera.projectPoint(this.toPoint().rotate(this.rotationCenter || this.position, this.rotation));
  }
  drawObject(graphics) {
    let projectedPoint = this.getRelevantPoints(graphics);
    if (projectedPoint == null) return;
    graphics.ctx.beginPath();
    graphics.ctx.arc(projectedPoint.x, projectedPoint.z, 5, 0, 2*Math.PI);
    graphics.ctx.fill();
  }
  projectedDistanceTo2dPoint(point) {
    // ...
  }
}




class Path extends GraphicsObject {
  constructor(points=[]) {
    super();
    this.points = points;
  }
  addPoint(point) {
    this.points.push(point);
  }
  getRelevantPoints(graphics) {
    let projectedPoints = [];
    for (let point of this.points) {
      let rotationCenter = this.rotationCenter || this.position;
      point = point.rotate(rotationCenter, this.rotation);
      projectedPoints.push(point);
      projectedPoints.push(point);
    }
    for (let i = 1; i < projectedPoints.length-1; i+=2) {
      let tmp = projectedPoints[i];
      projectedPoints[i] = graphics.camera.projectPoint(tmp, projectedPoints[i+1]);
      projectedPoints[i+1] = graphics.camera.projectPoint(projectedPoints[i+1], tmp);
    }
    return projectedPoints;
  }
  drawObject(graphics) {
    let points = this.getRelevantPoints(graphics);
    for (let i = 1; i < points.length-1; i+=2) {
      if (points[i] == null) console.log("BREAK!!!");
      graphics.ctx.beginPath();
      graphics.ctx.moveTo(points[i].x, points[i].z);
      graphics.ctx.lineTo(points[i+1].x, points[i+1].z);
      graphics.ctx.stroke();
    }
  }

  projectedDistanceTo2dPoint(graphics, point) {
    let shape = this.getRelevantPoints(graphics);

    // Checks if Point is inside the shape
    let isClosed = this.points[0].equals(this.points[this.points.length-1]);
    if (isClosed) {
      let x = point.x;
      let y = point.y;
      let inside = false;
      for (let i = 0, j = shape.length - 1; i < shape.length; j = i++) {
        let xi = shape[i].x;
        let yi = shape[i].z;
        let xj = shape[j].x;
        let yj = shape[j].z;
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      if (inside) return 0;
    }

    // Get minimal Distance
    let minDistance = Infinity;
    for (let i = 1; i < shape.length-1; i+=2) {
      let p1 = shape[i];
      let p2 = shape[(i+1).mod(shape.length)];
      // Calculate the distance from the point to the line defined by the current and next points
      let x = point.x;
      let y = point.y;
      let x1 = p1.x;
      let x2 = p2.x;
      let y1 = p1.z;
      let y2 = p2.z;
      let distance = Math.abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2);
      let projection = (((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2));
      if (projection < 0) {
        distance = Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);
      } else if (projection > 1) {
        distance = Math.sqrt((x - x2) ** 2 + (y - y2) ** 2);
      }
      if (distance < minDistance) minDistance = distance;
    }
    return minDistance;
  }
}




// NEW PLANE CLASS
// class Plane extends Path {
//   constructor(position, size) {
//     let corners = [];
//     corners.push(new Point(position.x-size.x/2, position.y-size.y/2, position.z-size.z/2));
//     corners.push(new Point(position.x+size.x/2, position.y-size.y/2, position.z-size.z/2));
//     corners.push(new Point(position.x+size.x/2, position.y-size.y/2, position.z+size.z/2));
//     corners.push(new Point(position.x-size.x/2, position.y-size.y/2, position.z+size.z/2));
//     super(corners);
//   }
//   intersect(line) {
//     let lineStart = line.points[0].toVector();
//     let v2 = line.points[1].toVector();
//     let lineDirection = (v2.sub(lineStart)).normalize();
//     let corners = this.getRelevantPoints();
//     let a = corners.a.toVector();
//     let b = corners.b.toVector();
//     let c = corners.c.toVector();
//
//     let n = a.sub(b).crossProduct(a.sub(c));
//     let t = -(n.dotProduct(lineStart) - n.dotProduct(a)) / n.dotProduct(lineDirection);
//     let intersectionPoint = lineStart.add(lineDirection.scale(t)).toPoint();
//     return intersectionPoint;
//   }
// }



// class Line extends GraphicsObject {
//   constructor(p1, p2) {
//     super();
//     this.p1 = p1;
//     this.p2 = p2;
//   }
//   getLength() {
//     return this.p1.toVector().getDistanceTo(this.p2);
//   }
//   getRelevantPoints(graphics) {
//     let p1 = this.p1.rotate(this.rotationCenter || this.position, this.rotation);
//     let p2 = this.p2.rotate(this.rotationCenter || this.position, this.rotation);
//     return {
//       p1: graphics.camera.projectPoint(p1, p2),
//       p2: graphics.camera.projectPoint(p2, p1)
//     };
//   }
//   drawObject(graphics) {
//     let points = this.getRelevantPoints(graphics);
//     if (points.p1 == null || points.p2 == null) return;
//     graphics.ctx.beginPath();
//     graphics.ctx.moveTo(points.p1.x, points.p1.z);
//     graphics.ctx.lineTo(points.p2.x, points.p2.z);
//     graphics.ctx.stroke();
//   }
//   projectedDistanceTo2dPoint(graphics, point) {
//     let points = this.getRelevantPoints(graphics);
//     let x = point.x;
//     let y = point.y;
//     let x1 = points.p1.x;
//     let x2 = points.p2.x;
//     let y1 = points.p1.z;
//     let y2 = points.p2.z;
//     const distanceToLine = Math.abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2);
//     let projection = (((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2));
//     if (projection < 0) {
//       return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);
//     } else if (projection > 1) {
//       return Math.sqrt((x - x2) ** 2 + (y - y2) ** 2);
//     }
//     return distanceToLine;
//   }
// }
//
//
class Plane extends GraphicsObject {
  constructor(position, size) {
    super(position, size);
  }
  getRelevantPoints() {
    let a = new Point(this.position.x-this.size.x/2, this.position.y-this.size.y/2, this.position.z-this.size.z/2);
    let b = new Point(this.position.x+this.size.x/2, this.position.y-this.size.y/2, this.position.z-this.size.z/2);
    let c = new Point(this.position.x+this.size.x/2, this.position.y-this.size.y/2, this.position.z+this.size.z/2);
    let d = new Point(this.position.x-this.size.x/2, this.position.y-this.size.y/2, this.position.z+this.size.z/2);
    let rotationCenter = this.rotationCenter || this.position;
    a = a.rotate(rotationCenter, this.rotation);
    b = b.rotate(rotationCenter, this.rotation);
    c = c.rotate(rotationCenter, this.rotation);
    d = d.rotate(rotationCenter, this.rotation);
    return {a: a, b: b, c: c, d: d}
  }
  intersect(line) {
    let lineStart = line.points[0].toVector();
    let v2 = line.points[1].toVector();
    let lineDirection = (v2.sub(lineStart)).normalize();
    let corners = this.getRelevantPoints();
    let a = corners.a.toVector();
    let b = corners.b.toVector();
    let c = corners.c.toVector();

    let n = a.sub(b).crossProduct(a.sub(c));
    let t = -(n.dotProduct(lineStart) - n.dotProduct(a)) / n.dotProduct(lineDirection);
    let intersectionPoint = lineStart.add(lineDirection.scale(t)).toPoint();
    return intersectionPoint;
  }
  drawObject(graphics) {
    let corners = this.getRelevantPoints();
    (new Path([corners.a, corners.b, corners.c, corners.d, corners.a])).drawObject(graphics);
  }
}


class Cube extends GraphicsObject {
  constructor(position, size) {
    super(position, size);
  }
  getRelevantPoints() {
    let rotationCenter = this.rotationCenter || this.position;
    return {
      p1: new Point(this.position.x-this.size.x/2, this.position.y-this.size.y/2, this.position.z-this.size.z/2).rotate(rotationCenter, this.rotation),
      p2: new Point(this.position.x+this.size.x/2, this.position.y-this.size.y/2, this.position.z-this.size.z/2).rotate(rotationCenter, this.rotation),
      p3: new Point(this.position.x+this.size.x/2, this.position.y-this.size.y/2, this.position.z+this.size.z/2).rotate(rotationCenter, this.rotation),
      p4: new Point(this.position.x-this.size.x/2, this.position.y-this.size.y/2, this.position.z+this.size.z/2).rotate(rotationCenter, this.rotation),
      p5: new Point(this.position.x-this.size.x/2, this.position.y+this.size.y/2, this.position.z-this.size.z/2).rotate(rotationCenter, this.rotation),
      p6: new Point(this.position.x+this.size.x/2, this.position.y+this.size.y/2, this.position.z-this.size.z/2).rotate(rotationCenter, this.rotation),
      p7: new Point(this.position.x+this.size.x/2, this.position.y+this.size.y/2, this.position.z+this.size.z/2).rotate(rotationCenter, this.rotation),
      p8: new Point(this.position.x-this.size.x/2, this.position.y+this.size.y/2, this.position.z+this.size.z/2).rotate(rotationCenter, this.rotation)
    }
  }
  drawObject(graphics) {
    // (new Dot(this.position)).draw(graphics);
    let points = this.getRelevantPoints();
    (new Path([points.p1, points.p2, points.p3, points.p4, points.p1])).drawObject(graphics);
    (new Path([points.p5, points.p6, points.p7, points.p8, points.p5])).drawObject(graphics);
    (new Path([points.p1, points.p5])).drawObject(graphics);
    (new Path([points.p2, points.p6])).drawObject(graphics);
    (new Path([points.p3, points.p7])).drawObject(graphics);
    (new Path([points.p4, points.p8])).drawObject(graphics);
  }
}



// class Text extends GraphicsObject {
//   constructor(position, size) {
//     super(position, size);
//     this.text = "TextObject";
//     this.textSize = 30;
//   }
//   getRelevantPoints(graphics) {
//     let a = new Point(this.position.x, this.position.y, this.position.z);
//     let b = new Point(this.position.x, this.position.y, this.position.z-20);
//     let c = new Point(this.position.x-20, this.position.y, this.position.z);
//     let rotationCenter = this.rotationCenter || this.position;
//     a = a.rotate(rotationCenter, this.rotation);
//     b = b.rotate(rotationCenter, this.rotation);
//     c = c.rotate(rotationCenter, this.rotation);
//
//     (new Dot(a)).draw(graphics);
//     (new Dot(b)).draw(graphics);
//     (new Dot(c)).draw(graphics);
//
//     a = graphics.camera.projectPoint(a);
//     b = graphics.camera.projectPoint(b);
//     c = graphics.camera.projectPoint(c);
//     return {
//       p1: a,
//       p2: b,
//       p3: c
//     }
//   }
//   drawObject(graphics) {
//     let plane = new Plane();
//     plane.position = this.position;
//     plane.size = this.size;
//     plane.drawObject(graphics);
//
//     let points = this.getRelevantPoints(graphics);
//
//     graphics.ctx.font = "20px futura";
//     graphics.ctx.textAlign = "center";
//     graphics.ctx.fillStyle = this.fillColor.toString();
//     //graphics.ctx.setTransform(1, -0.2, 0, 1, 0, 0);
//     graphics.ctx.fillText(this.text, points.p1.x, points.p1.z);
//     //graphics.ctx.setTransform(1, 0, 0, 1, 0, 0);
//   }
// }




class Ellipse extends GraphicsObject {
  constructor(position, size) {
    super(position, size);
  }
  getRelevantPoints(graphics) {
    let points = [];
    let resolution = 50;
    for (let i = 0; i < resolution; i++) {
      let point = new Point();
      point.x = this.position.x + this.size.x*Math.sin(2*Math.PI*i/resolution);
      point.y = this.position.y + this.size.y*Math.cos(2*Math.PI*i/resolution);
      point.z = this.position.z + this.size.z*Math.cos(2*Math.PI*i/resolution);
      point = point.rotate(this.rotationCenter || this.position, this.rotation);
      points.push(point);
    }
    return points;
  }
  drawObject(graphics) {
    let points = this.getRelevantPoints(graphics);
    let path = new Path();
    for (let i = 0; i <= points.length; i++) {
      path.addPoint(points[i.mod(points.length)]);
    }
    path.drawObject(graphics);
  }
}





class Sphere extends GraphicsObject {
  constructor() {
    super();
  }
  // ...
}

class Spline extends GraphicsObject {
  constructor() {
    super();
  }
  // ...
}



Number.prototype.mod = function (n) {
  "use strict";
  return ((this % n) + n) % n;
};
