<html>

<head>
  <meta charset="utf-8"/>
  <title>Autoencoder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <base href="/code/block_paeca/">
  <link rel="stylesheet" href="/sources/common.css?v=18">
  <link rel="stylesheet" href="index.css?v=18">
</head>

<body>
  <t class="title" id="title">PAEBCA</t><br>
  <t class="text">Compression</t>
  <div id="controlContainer">
    <div class="button" type="button" onclick="startTraining();">TRAIN</div>
    <div class="button" type="button" onclick="testModel();">TEST</div>
  </div><br>
  <t class="text" id="statusText"></t>
</body>
</html>


<script src="nn.js"></script>
<script>

// Global Variables
// const shape = [2400, 700, 200, 50, 30, 10, 30, 50, 200, 700, 2400];
// const shape = [2400, 700, 80, 50, 40, 40, 30, 10, 30, 40, 40, 50, 80, 700, 2400];
// const shape = [2400, 500, 80, 30, 10, 30, 80, 500, 2400];
const shape = [2400, 400, 80, 30, 10, 30, 80, 400, 2400];
let generationSize = 100;
let generation = [];
let generationCounter = 0;
let bestModel = new NeuralNetwork(shape);
let trainingData;

function log(msg) {
  document.getElementById("statusText").innerHTML = msg;
}

async function startTraining() {
  log("Getting Data...");
  await new Promise(res => setTimeout(res, 100));
  fetch("trainingtext.txt")
  .then(res => res.text())
  .then(async function(res) {
    log("Got Data...");
    await new Promise(res => setTimeout(res, 100));
    let ind = Math.random()*(res.length-300);
    trainingData = stringToBitArray(res.substring(ind, ind+300));
    createNewGeneration();
  });
}

// Creates a new generation
async function createNewGeneration() {
  generationCounter++;
  if (generationCounter > 10) return;
  let isEmpty = generation.length == 0;
  for (let i = 0; i < generationSize; i++) {
    let nn = isEmpty ? new NeuralNetwork(shape) : generation[i];
    if (generationCounter > 1) {
      nn.weights = bestModel.weights.clone();
      if (i > 0) nn.mutate(0.01);
    }
    if (isEmpty) generation.push(nn);
    log("Creating new Generation: " + Math.round(i/generationSize*100) + "%");
    await new Promise(res => setTimeout(res, 10));
  }
  console.log(isEmpty, generation.length);
  testGeneration();
}

// Tests a generation and finds the best one
async function testGeneration() {
  let minError = Infinity;
  let indexOfBest;
  for (let i = 0; i < generationSize; i++) {
    let output = generation[i].predict(trainingData);
    let error = 0;
    for (let j = 0; j < trainingData.length; j++) {
      error += Math.pow(trainingData[j]-output[j], 2);
    }
    if (error < minError) {
      minError = error;
      indexOfBest = i;
    }
    log("Generation " + generationCounter + " (" + Math.round(i/generationSize*100) + "%)<br>Error: " + minError);
    await new Promise(res => setTimeout(res, 10));
  }
  console.log(minError);
  bestModel.weights = generation[indexOfBest].weights.clone();
  createNewGeneration();
}

// Tests the best model in practise
function testModel() {
  let inputText = "Hey! My Name is Merlin Hof and this is a test text for my new PAEBCA (which is short for \"Pretrained Auto Encoder Blocked Compression Algorithm\"). One Block of text with a length of 300 Characters (or 300 Bytes) can be compressed to just 10 floating point numbers. That's very cool! :D";
  inputText = inputText.substring(0, 300);
  while (inputText.length < 300) {
    inputText += "\0";
  }
  let input = stringToBitArray(inputText);
  let prediction = bestModel.predict(input);
  let bottleNeckIndex = bestModel.shape.indexOf(Math.min(...shape));
  let compressedData = bestModel.neuronInputs[bottleNeckIndex].map(x => Math.round(1000*x)/1000);
  log("<b>Original</b><br>" + inputText + "<br><br><b>Compressed</b><br>" + compressedData + "<br><br><b>Decompressed</b><br>" + bitArrayToString(prediction));
}

function stringToBitArray(str) {
  let res = [];
  for (let i = 0; i < str.length; i++) {
    let binChar = str.charCodeAt(i).toString(2);
    let tmpBinArr = [];
    while (tmpBinArr.length + binChar.length < 8) {
      tmpBinArr.push(0);
    }
    for (let j = 0; j < binChar.length; j++) {
      tmpBinArr.push(parseInt(binChar[j]));
    }
    if (tmpBinArr.length != 8) console.log("ERR: " + str[i]);
    res = res.concat(tmpBinArr);
  }
  return res;
}

function bitArrayToString(arr) {
  let res = "";
  for (let i = 0; i < arr.length; i+=8) {
    let charCode = 0;
    for (let j = 0; j < 8; j++) {
      if (arr[i+j] >= 0.5) charCode += Math.pow(2, 7-j);
    }
    res += String.fromCharCode(charCode);
  }
  return res;
}

function createRandomBitArray(len) {
  let res = [];
  for (let i = 0; i < len; i++) {
    res.push(Math.random() < 0.5 ? 0 : 1);
  }
  return res;
}

// Clones an array recursively (infinite depth)
Array.prototype.clone = function() {
  let res = [];
  for (let i = 0; i < this.length; i++) {
    let newVal = Array.isArray(this[i]) ? this[i].clone() : this[i];
    res.push(newVal);
  }
  return res;
}

</script>
